# Implementation Plan: Forest Focus - Pomodoro Timer

**Branch**: `001-forest-focus-core` | **Date**: 2025-10-29 | **Spec**: [forest-focus-spec.md](../../forest-focus-spec.md)  
**Input**: Feature specification from `.specify/memory/forest-focus-spec.md`

## Summary

Build a radically simple, offline-first iOS Pomodoro timer app where users start 25-minute focus sessions to "plant" trees that grow through 5 stages. Completed sessions save trees to a personal forest; cancelled sessions kill the tree. Technical approach: SwiftUI + SwiftData (iOS 17+), Combine-based timer with background accuracy, local notifications via UNUserNotificationCenter, 60fps animations with Core Animation, XCTest/XCUITest for TDD, memory budget <50MB during active sessions.

## Technical Context

**Language/Version**: Swift 5.9+  
**Primary Dependencies**: SwiftUI, SwiftData, Combine, UserNotifications (all native iOS SDK)  
**Storage**: SwiftData (iOS 17+) for persistent session/forest data  
**Testing**: XCTest (unit), XCUITest (UI), XCTMetrics (performance)  
**Target Platform**: iOS 17.0+  
**Project Type**: Single iOS app (native mobile)  
**Performance Goals**: 
- 60fps animations (16.67ms frame time max)
- <2s cold start to interactive UI
- <50MB memory during active sessions
- Timer accuracy ±1 second over 25 minutes

**Constraints**: 
- Offline-first: zero network calls
- No third-party dependencies
- TDD mandatory (tests before implementation)
- Background timer accuracy with monotonic clock
- VoiceOver + Dynamic Type support

**Scale/Scope**: 
- 3 main screens (Timer, Forest Grid, Stats)
- ~10 core SwiftUI views
- 4 SwiftData models
- Support for 1000+ completed sessions without performance degradation

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### ✅ Radical Simplicity
- **PASS**: Single-purpose focus timer, minimal features, no settings bloat
- **PASS**: No custom durations, tree species, themes - started simple

### ✅ Offline-First
- **PASS**: SwiftData is local-only storage
- **PASS**: No network frameworks, no analytics, no cloud sync

### ✅ Test-First Development
- **PASS**: Plan includes TDD workflow with XCTest/XCUITest
- **GATE**: Must write tests before each implementation phase

### ✅ Performance Standards
- **PASS**: 60fps target with Core Animation profiling strategy
- **PASS**: <2s cold start with Time Profiler validation strategy
- **PASS**: <50MB memory budget with Memory Graph validation strategy
- **PASS**: Battery conscious - no background processing, local notifications only

### ✅ Accessibility First
- **PASS**: VoiceOver labels planned for all interactive elements
- **PASS**: Dynamic Type support for all text via SwiftUI defaults
- **PASS**: Reduce Motion alternatives for animations
- **PASS**: High Contrast support via system colors

### ✅ Technical Constraints
- **PASS**: Swift only, native iOS SDK only
- **PASS**: SwiftUI primary UI framework
- **PASS**: No third-party dependencies
- **PASS**: Native storage (SwiftData)

### Gates for Phases
- **Phase 0 (Research)**: Document SwiftData schema design, Combine timer architecture, background timing strategy
- **Phase 1 (Design)**: Create data models, define contracts, validate memory budgets
- **Phase 2 (TDD Implementation)**: Write tests first, implement to pass, profile with Instruments

## Project Structure

### Documentation (this feature)

```text
.specify/memory/specs/001-forest-focus-core/
├── plan.md              # This file
├── research.md          # Phase 0: SwiftData schema, Combine timer patterns, background timing
├── data-model.md        # Phase 1: SwiftData models, relationships, queries
├── quickstart.md        # Phase 1: Dev setup, run tests, profile with Instruments
├── contracts/           # Phase 1: API contracts between ViewModels and Views
│   ├── timer-contract.md
│   ├── forest-contract.md
│   └── stats-contract.md
└── tasks.md             # Phase 2: Generated by /speckit.tasks (not created by this plan)
```

### Source Code (repository root)

```text
ForestFocus/
├── ForestFocusApp.swift           # App entry point, SwiftData container setup
├── Models/                        # SwiftData models (Phase 1)
│   ├── FocusSession.swift         # @Model: session state, timestamps, completion
│   ├── SessionState.swift         # Enum: active, paused, completed, abandoned
│   └── ForestStats.swift          # Computed stats from sessions query
├── ViewModels/                    # Business logic + state management (Phase 1-2)
│   ├── TimerViewModel.swift       # Combine timer, background sync, state machine
│   ├── ForestViewModel.swift      # Sessions query, grid data source
│   └── StatsViewModel.swift       # Aggregate calculations, streak logic
├── Views/                         # SwiftUI views (Phase 2)
│   ├── ContentView.swift          # TabView: Timer/Forest/Stats
│   ├── Timer/
│   │   ├── TimerView.swift        # Main session screen
│   │   ├── TreeView.swift         # Animated tree with 5 growth stages
│   │   └── CountdownView.swift    # MM:SS display with Dynamic Type
│   ├── Forest/
│   │   ├── ForestGridView.swift   # LazyVGrid of completed trees
│   │   ├── TreeCell.swift         # Single tree in grid
│   │   └── EmptyForestView.swift  # Empty state
│   └── Stats/
│       └── StatsView.swift        # Statistics dashboard
├── Services/                      # Platform integrations (Phase 2)
│   ├── NotificationService.swift  # UNUserNotificationCenter wrapper
│   ├── TimerService.swift         # CACurrentMediaTime monotonic clock
│   └── BackgroundService.swift    # Scene lifecycle, background sync
└── Resources/
    ├── Assets.xcassets            # Tree stage images, colors
    └── Info.plist                 # Notification permissions, background modes

ForestFocusTests/                  # XCTest unit tests (Phase 1-2)
├── ModelTests/
│   ├── FocusSessionTests.swift    # Test session state transitions
│   └── ForestStatsTests.swift     # Test stats calculations, streak logic
├── ViewModelTests/
│   ├── TimerViewModelTests.swift  # Test timer logic, pause/resume
│   ├── ForestViewModelTests.swift # Test query logic, filtering
│   └── StatsViewModelTests.swift  # Test edge cases (midnight, streaks)
└── ServiceTests/
    ├── NotificationServiceTests.swift
    └── TimerServiceTests.swift    # Test background time sync

ForestFocusUITests/                # XCUITest UI tests (Phase 2)
├── TimerFlowTests.swift           # Start, pause, resume, cancel, complete
├── ForestViewTests.swift          # Grid display, empty state, navigation
├── AccessibilityTests.swift       # VoiceOver, Dynamic Type, Reduce Motion
└── PerformanceTests.swift         # XCTMetrics: cold start, animation fps, memory
```

**Structure Decision**: Single iOS app structure chosen because this is a standalone mobile app with no backend/API requirements. All logic lives in the app target. Tests separated into unit (ForestFocusTests) and UI (ForestFocusUITests) targets following Xcode conventions.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

*No violations detected. All constitution requirements met.*

---

## Phase 0: Research & Architecture

**Goal**: Understand SwiftData patterns, Combine timer implementation, background timing strategies, and animation performance constraints.

**Deliverable**: `research.md` with findings on:

### 0.1 SwiftData Schema Design
- **Research**: SwiftData @Model macro, relationships, queries, migrations
- **Questions**:
  - How to model `FocusSession` with state transitions?
  - Query patterns for "today's sessions", "streak calculation", "total stats"?
  - Performance of LazyVGrid with 1000+ sessions?
  - How to handle SwiftData in-memory testing (ModelContainer configuration)?

### 0.2 Combine Timer Architecture
- **Research**: Combine `Timer.publish()` vs `CADisplayLink` for 60fps updates
- **Questions**:
  - Best pattern for pausing/resuming Combine publishers?
  - How to sync timer with CACurrentMediaTime (monotonic clock)?
  - Memory impact of Combine subscriptions (<50MB budget)?
  - How to cancel subscriptions on background/foreground transitions?

### 0.3 Background Timing Strategy
- **Research**: ScenePhase, App lifecycle, background time tracking
- **Questions**:
  - How to capture background timestamp and sync on foreground return?
  - Use NotificationCenter for `sceneDidEnterBackground`?
  - Store `backgroundTimestamp` in UserDefaults vs in-memory?
  - Handle force-quit detection (mark session as abandoned)?

### 0.4 Notification Scheduling
- **Research**: UNUserNotificationCenter, permission flow, notification actions
- **Questions**:
  - Schedule notification with exact 25-minute trigger?
  - Handle permission denial gracefully (no-op)?
  - Deep link to app when notification tapped?
  - Cancel notification if session cancelled/app foregrounded?

### 0.5 Animation Performance
- **Research**: SwiftUI animation modifiers, Core Animation layers, 60fps profiling
- **Questions**:
  - Best approach for tree growth animations (withAnimation vs implicit)?
  - Use Shape/Path for tree stages or Image assets?
  - How to respect `accessibilityReduceMotion`?
  - Profile with Core Animation Instrument - what metrics to track?

### 0.6 Memory Management
- **Research**: Memory budget strategies, SwiftUI view lifecycle, retain cycles
- **Questions**:
  - Typical SwiftUI app baseline memory usage?
  - How to detect/prevent retain cycles in ViewModels?
  - LazyVGrid memory efficiency with 1000+ items?
  - When to use `@StateObject` vs `@ObservedObject` vs `@EnvironmentObject`?

**Output**: `research.md` with code snippets, Apple documentation references, memory profiling strategy, and architectural decisions.

---

## Phase 1: Design & Contracts

**Goal**: Define SwiftData models, ViewModel contracts, and testing strategy. Validate architecture decisions from Phase 0.

**Deliverables**: 
- `data-model.md` - SwiftData schema with relationships
- `quickstart.md` - Setup instructions, test commands, profiling workflow
- `contracts/*.md` - Input/output contracts for each ViewModel

### 1.1 Data Model Design

**File**: `data-model.md`

Define SwiftData models with:
- **FocusSession**: `@Model` with `id`, `startTime`, `endTime`, `state`, `duration`
- **SessionState**: Enum `active`, `paused`, `completed`, `abandoned`
- **ForestStats**: Struct (computed, not persisted) with totals/streaks
- Queries: "all completed", "today's sessions", "sessions for date range"
- Relationships: None needed (flat session list)
- Migrations: N/A for v1.0

### 1.2 ViewModel Contracts

**Files**: `contracts/timer-contract.md`, `contracts/forest-contract.md`, `contracts/stats-contract.md`

Define for each ViewModel:
- **Inputs**: User actions (start, pause, resume, cancel)
- **Outputs**: Published properties for View binding
- **Side Effects**: SwiftData persistence, notification scheduling
- **Testing Doubles**: Mock ModelContext for unit tests

Example for `TimerViewModel`:
```swift
// Inputs
func startSession()
func pauseSession()
func resumeSession()
func cancelSession()

// Outputs (Published)
@Published var remainingTime: TimeInterval
@Published var currentState: SessionState
@Published var treeStage: Int (1-5)

// Side Effects
- Persist session to SwiftData on completion/abandon
- Schedule notification on start
- Cancel notification on cancel/foreground
```

### 1.3 Quickstart Guide

**File**: `quickstart.md`

Document:
- Xcode project setup (iOS 17+ deployment target)
- Run unit tests: `Cmd+U`
- Run UI tests: `Cmd+Shift+U`
- Profile cold start: Instruments > Time Profiler
- Profile animations: Instruments > Core Animation
- Profile memory: Instruments > Allocations + Leaks
- Target benchmarks: <2s cold start, 60fps, <50MB memory

### 1.4 Test Strategy

Define test pyramid:
- **Unit Tests (70%)**: Models, ViewModels, Services, Stats calculations
- **UI Tests (20%)**: Critical paths (start/complete, pause/resume, cancel)
- **Performance Tests (10%)**: XCTMetrics for cold start, animation FPS, memory

**Coverage Goal**: 80% for business logic (ViewModels, Models, Services)

---

## Phase 2: Test-First Implementation

**Goal**: Implement features using TDD (Red-Green-Refactor). Write tests first, then implement to make tests pass.

**Deliverable**: `tasks.md` generated by `/speckit.tasks` command

### Implementation Order (by Priority from Spec)

#### 2.1 P1: Session Start and Complete (User Story 1)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `TimerViewModelTests.testStartSession()` - verify timer starts at 25:00
   - `TimerViewModelTests.testTreeGrowthStages()` - verify stages advance every 5 min
   - `TimerViewModelTests.testSessionCompletion()` - verify session persisted
2. **GREEN**: Implement
   - `TimerViewModel` with Combine timer
   - `TimerService` with CACurrentMediaTime
   - `FocusSession` SwiftData model
3. **REFACTOR**: Extract timer logic, optimize Combine subscriptions
4. **PROFILE**: Memory usage <10MB baseline increase

#### 2.2 P1: Pause and Resume (User Story 2)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `TimerViewModelTests.testPauseSession()` - verify timer stops
   - `TimerViewModelTests.testResumeSession()` - verify timer continues
   - `TimerViewModelTests.testPauseDurationNotCounted()` - verify accurate total time
2. **GREEN**: Implement
   - Pause/resume logic in `TimerViewModel`
   - State machine transitions (active ↔ paused)
3. **REFACTOR**: Simplify state transitions
4. **PROFILE**: No memory leaks on pause/resume cycle

#### 2.3 P1: Cancel Session (User Story 3)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `TimerViewModelTests.testCancelSession()` - verify session marked abandoned
   - `TimerUITests.testCancelConfirmation()` - verify UI confirmation dialog
2. **GREEN**: Implement
   - Cancel logic with confirmation
   - Persist abandoned session
3. **REFACTOR**: Extract confirmation dialog to reusable component
4. **PROFILE**: Verify abandoned sessions don't leak memory

#### 2.4 P1: Background Timer Accuracy (User Story 4)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `BackgroundServiceTests.testBackgroundTimeSync()` - verify time delta calculation
   - `TimerViewModelTests.testBackgroundCompletionDetection()` - verify session completes
2. **GREEN**: Implement
   - `BackgroundService` with ScenePhase observation
   - Background timestamp capture + foreground sync
   - Session completion check on foreground return
3. **REFACTOR**: Optimize ScenePhase listener
4. **PROFILE**: Timer accuracy ±1 second over 25 minutes

#### 2.5 P2: Forest Grid View (User Story 5)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `ForestViewModelTests.testCompletedSessionsQuery()` - verify query returns completed only
   - `ForestViewModelTests.testChronologicalOrdering()` - verify newest first
   - `ForestUITests.testEmptyState()` - verify empty state shown
2. **GREEN**: Implement
   - `ForestViewModel` with SwiftData query
   - `ForestGridView` with LazyVGrid
   - `EmptyForestView`
3. **REFACTOR**: Optimize LazyVGrid performance
4. **PROFILE**: Smooth scrolling at 60fps with 1000+ trees

#### 2.6 P2: Statistics (User Story 6)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `StatsViewModelTests.testTotalTreesCalculation()`
   - `StatsViewModelTests.testStreakCalculation()` - edge cases (midnight, gaps)
   - `StatsViewModelTests.testTodaysCount()` - resets at midnight
2. **GREEN**: Implement
   - `StatsViewModel` with aggregate queries
   - Streak calculation algorithm
   - Today's count with date filtering
3. **REFACTOR**: Extract streak logic to pure function
4. **PROFILE**: Stats calculation <100ms for 1000+ sessions

#### 2.7 P2: Local Notifications (User Story 7)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `NotificationServiceTests.testPermissionRequest()`
   - `NotificationServiceTests.testScheduleNotification()` - verify 25-min trigger
   - `NotificationServiceTests.testCancelNotification()`
2. **GREEN**: Implement
   - `NotificationService` wrapper for UNUserNotificationCenter
   - Permission request on first launch
   - Schedule/cancel notification logic
3. **REFACTOR**: Simplify permission handling
4. **PROFILE**: No memory impact from notification scheduling

### 2.8 Tree Animations (Continuous)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `TreeViewTests.testGrowthAnimation()` - verify animation fires
   - `TreeUITests.testReduceMotion()` - verify alternative when enabled
2. **GREEN**: Implement
   - `TreeView` with 5 stage images/shapes
   - SwiftUI `withAnimation()` for transitions
   - `accessibilityReduceMotion` check
3. **REFACTOR**: Extract animation constants
4. **PROFILE**: 60fps with Core Animation Instrument

### 2.9 Accessibility (Continuous)
**TDD Cycle**:
1. **RED**: Write failing tests
   - `AccessibilityTests.testVoiceOverLabels()` - all buttons labeled
   - `AccessibilityTests.testDynamicType()` - text scales at XXXL
2. **GREEN**: Implement
   - `.accessibilityLabel()` on all interactive elements
   - Dynamic Type via `.font(.body)` SwiftUI defaults
   - High contrast via system colors
3. **REFACTOR**: Audit all views for accessibility
4. **PROFILE**: VoiceOver navigation test (<30s to complete session)

---

## Phase 3: Performance Validation

**Goal**: Validate all performance requirements with Instruments profiling.

### 3.1 Cold Start Performance
- **Tool**: Time Profiler
- **Target**: <2 seconds to interactive UI
- **Method**: Launch app from cold state, measure time to first tap-responsive view
- **Pass Criteria**: Main thread shows UI ready in <2000ms

### 3.2 Animation Performance
- **Tool**: Core Animation Instrument
- **Target**: 60fps (16.67ms max frame time)
- **Method**: Run session through all 5 growth stages, profile frame rate
- **Pass Criteria**: No frames exceed 16.67ms, no dropped frames

### 3.3 Memory Budget
- **Tool**: Allocations + Leaks
- **Target**: <50MB during active session
- **Method**: Start session, run for 25 minutes, check memory graph
- **Pass Criteria**: Total memory <50MB, zero leaks detected

### 3.4 Timer Accuracy
- **Tool**: Manual testing with external timer
- **Target**: ±1 second over 25 minutes
- **Method**: Start session, background app, compare to stopwatch after 25 min
- **Pass Criteria**: App timer within 1 second of external reference

### 3.5 Battery Impact
- **Tool**: Energy Log
- **Target**: Minimal impact (no background processing)
- **Method**: Run session, check energy usage in Xcode
- **Pass Criteria**: Energy impact rated as "Low"

---

## Phase 4: Accessibility Validation

**Goal**: Validate all accessibility requirements.

### 4.1 VoiceOver Navigation
- **Tool**: iOS VoiceOver simulator
- **Test**: Complete full session using only VoiceOver
- **Pass Criteria**: All controls reachable, actions clear, session completable

### 4.2 Dynamic Type
- **Tool**: Xcode Preview with Dynamic Type sizes
- **Test**: Preview all views at XS, S, M, L, XL, XXL, XXXL sizes
- **Pass Criteria**: All text readable, no truncation, no layout breaks

### 4.3 Reduce Motion
- **Tool**: Simulator with Reduce Motion enabled
- **Test**: Run session, verify alternative animations appear
- **Pass Criteria**: Tree growth visible without motion (fade/scale only)

### 4.4 High Contrast
- **Tool**: Simulator with Increase Contrast enabled
- **Test**: Verify tree stages distinguishable, buttons clear
- **Pass Criteria**: All elements meet contrast ratios

---

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|-----------|
| SwiftData learning curve (new in iOS 17) | Medium | Phase 0 research, prototype simple CRUD operations |
| Background timer drift (iOS limitations) | High | Use CACurrentMediaTime (monotonic), test extensively |
| 60fps animations with complex tree visuals | Medium | Start with simple shapes, profile early, optimize rendering |
| Memory budget exceeded with Combine subscriptions | Medium | Profile after each ViewModel, use weak references |
| XCUITest flakiness for 25-minute timer tests | Low | Use accelerated time for tests (dependency injection) |
| Force-quit detection (abandoned session) | Low | Document as acceptable limitation (iOS restriction) |

---

## Definition of Done

### Per Phase
- **Phase 0**: Research document complete, architecture decisions documented
- **Phase 1**: All contracts defined, data models designed, quickstart written, zero ambiguity
- **Phase 2**: All tests passing, 80% code coverage, constitution checks pass
- **Phase 3**: All performance benchmarks met (profiling evidence documented)
- **Phase 4**: All accessibility validation passed (screenshots + test results)

### Overall Feature
- ✅ All 50 functional requirements implemented
- ✅ All P1 user stories deliverable independently (tested + working)
- ✅ All P2 user stories implemented and integrated
- ✅ Constitution gates passed:
  - TDD: Tests written before implementation (git history evidence)
  - Performance: <2s cold start, 60fps animations, <50MB memory (Instruments evidence)
  - Accessibility: VoiceOver, Dynamic Type, Reduce Motion validated (test results)
  - Simplicity: Zero third-party deps, minimal features, no bloat
  - Offline: Zero network calls (static analysis confirmation)
- ✅ Code reviewed by human (accessibility + performance focus)
- ✅ Merged to main via PR with passing CI (all tests green)

---

## Open Questions for Phase 0 Research

1. **SwiftData Testing**: Best practice for in-memory ModelContainer in unit tests?
2. **Combine Timer**: Memory footprint of `Timer.publish().autoconnect()` over 25 minutes?
3. **Background Sync**: Can we use BackgroundTasks framework or is ScenePhase sufficient?
4. **Tree Visuals**: Vector shapes (SF Symbols style) or raster images (PNG assets)?
5. **Force Quit Detection**: Feasible to detect and mark session abandoned, or document as limitation?
6. **Notification Deep Link**: UNNotificationResponse handling for opening to specific view?
7. **Streak Calculation**: Store streak in SwiftData or compute on-demand? (performance trade-off)

These will be answered in `research.md` during Phase 0.
